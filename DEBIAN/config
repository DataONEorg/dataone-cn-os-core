#!/bin/bash -x

ACTION=${1}
NEW_VERSION=${2}

# Source the debconf library
if [ -e "/usr/share/debconf/confmodule" ]; then
    . /usr/share/debconf/confmodule
fi

#Reminder: Don't echo to STDOUT. it messes up debconf

# functions to echo to STDERR or the install log instead of STDOUT
D1_LOG_DIR=/var/log/dataone
D1_CONF=/etc/dataone
D1_CLIENTCERT_DIR=${D1_CONF}/client/certs

if [ ! -e $D1_LOG_DIR ]; then
    mkdir -p $D1_LOG_DIR
fi

logError () {
    echo "$@" 1>&2;
}

log () {
    now=$(date "+%Y-%m-%d %H:%M:%S %Z: ")
    echo "${now}$@" >> ${D1_LOG_DIR}/dataone-cn-os-core.install.log;
}

log "dataone-cn-os-core.config script called with action: ${ACTION}"

# Upgrade or install: check for previous values
db_get dataone-cn-os-core/cn.installed
if [[ "${RET}" != *true* ]]; then
	
   # Ask the person installing what environment should be installed
   db_input high dataone-cn-os-core/cn.context.label
   # What is the node id of this CN?
   db_input high dataone-cn-os-core/cn.nodeid
    
   # populate the x509 certificate filenames from /etc/dataone/client/certs
   # and substitute them into a parameter in the description
    if [ -d ${D1_CLIENTCERT_DIR} ]; then
        clientcert_dir_contents=(`ls ${D1_CLIENTCERT_DIR}| xargs`)
    
        clientcert_file_count=${#clientcert_dir_contents[*]}
        if [ ${clientcert_file_count} > 0 ]; then
            # the certificate has already been set once
            # pull out the names and get the correct filename
            filename_listing=${clientcert_dir_contents[@]}
            db_subst dataone-cn-os-core/cn.client.certificate.filename certificateFilenames $filename_listing
            db_input high dataone-cn-os-core/cn.client.certificate.filename
            db_set dataone-cn-os-core/cn.client.certificate.filepath "false"
        else
            db_input high dataone-cn-os-core/cn.client.certificate.filepath
            db_set dataone-cn-os-core/cn.client.certificate.filename "false"
        fi
    else
            db_input high dataone-cn-os-core/cn.client.certificate.filepath
            db_set dataone-cn-os-core/cn.client.certificate.filename "false"
    fi
    
    db_go
    
    db_get dataone-cn-os-core/cn.context.label
    CONTEXT=${RET}
    
    # we can't use [while read line/do/done < file] here because of conflicts
    # with read in the db_set and db_fset commands.    
    OLDIFS=$IFS
    IFS=$'\n';
    lines=$(cat "${D1_CONF}/d1-${CONTEXT,,}-environment.conf")
    for line in $lines; 
        do 
            if [[ $line == dataone* ]]; then
                if [[ $line == dataone*seen* ]]; then
                    db_fset $line
                    log "Called db_fset $line"
                else
                    db_set $line
                    log "Called db_set $line"
                fi
            fi
        done
    IFS=$OLDIFS
    
    # Ask for the D1 public cert and private key locations
    db_input high dataone-cn-os-core/cn.server.privatekey.filepath
    
    # Ask for the Java keystore password
    db_input high dataone-cn-os-core/cn.keystore.password
    
    # Ask for the LDAP database admin password
    db_input high dataone-cn-os-core/cn.openldap.password
    
    # Ask if the CNs should be sync'd
    db_input high dataone-cn-os-core/cn.openldap.synchronized
    db_go
    
    # If we intend to synchronize, get the unique serverID for LDAP and whether
    # or not this is the first CN to be configured in the environment
    db_get dataone-cn-os-core/cn.openldap.synchronized
    if [[ "${RET}" == *true* ]]; then
        db_input high dataone-cn-os-core/cn.openldap.serverID
        db_input high dataone-cn-os-core/cn.openldap.firstcn
        db_go
    else
    	### this is a standalone CN, it still needs to be configured
    	### as the first CN
    	db_set dataone-cn-os-core/cn.openldap.firstcn "true"
    fi
else
    log "Upgrading the package. No configuration questions asked."
    
    # pick up changes in the per-environment preseeded files
    db_get dataone-cn-os-core/cn.context.label
    CONTEXT=${RET}
    
    # we can't use [while read line/do/done < file] here because of conflicts
    # with read in the db_set and db_fset commands.    
    OLDIFS=$IFS
    IFS=$'\n';
    lines=$(cat "${D1_CONF}/d1-${CONTEXT,,}-environment.conf")
    for line in $lines; 
        do 
            if [[ $line == dataone* ]]; then
                if [[ $line == dataone*seen* ]]; then
                    db_fset $line
                    log "Called db_fset $line"
                else
                    db_set $line
                    log "Called db_set $line"
                fi
            fi
        done
    IFS=$OLDIFS
    
fi

exit 0